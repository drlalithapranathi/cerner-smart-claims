<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Smart Claims – Callback</title>
  <script src="https://cdn.jsdelivr.net/npm/fhirclient/build/fhir-client.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 20px; }
    h1 { margin-bottom: 8px; }
    .section { margin: 16px 0; padding: 12px; border: 1px solid #ddd; border-left: 4px solid #999; background:#fafafa }
    .ok { border-left-color:#28a745; background:#f4fbf5 }
    .warn { border-left-color:#ffc107; background:#fff9e6 }
    .err { border-left-color:#dc3545; background:#fff4f4 }
    .highlight { border-left-color:#007bff; background:#f0f8ff }
    .radiology { border-left-color:#6f42c1; background:#f8f7ff }
    pre { margin: 8px 0 0; overflow:auto; }
    small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <h1>Smart Claims</h1>
  <div class="section"><small class="mono">Completing SMART sign-in…</small></div>
  <div id="out"></div>

  <script>
    const out = document.getElementById("out");
    const add = (cls, title, obj) => {
      const d = document.createElement("div");
      d.className = `section ${cls||""}`;
      d.innerHTML = `<strong>${title}</strong>${obj ? `<pre>${JSON.stringify(obj, null, 2)}</pre>` : ""}`;
      out.appendChild(d);
    };

    // Utility: fetch all pages (Bundle navigation)
    async function fetchAll(client, firstUrl, maxPages = 10) {
      let url = firstUrl, pages = 0, entries = [];
      while (url && pages < maxPages) {
        const bundle = await client.request(url, { flat: false });
        entries.push(...(bundle.entry || []));
        url = (bundle.link || []).find(l => l.relation === "next")?.url || null;
        pages++;
      }
      return entries;
    }

    (async () => {
      try {
        const client = await FHIR.oauth2.ready(); // completes code+PKCE exchange

        // Basic connection info (do NOT print the raw token)
        const token = client.state?.tokenResponse || {};
        add("ok", "SMART connection established", {
          serverUrl: client.state?.serverUrl,
          tokenType: token.token_type,
          scope: token.scope,
          expires_in: token.expires_in
        });

        // Server capabilities (nice sanity check)
        try {
          const meta = await client.request("metadata");
          add("", "FHIR server metadata (summary)", {
            fhirVersion: meta.fhirVersion,
            software: meta.software?.name,
            status: meta.status
          });
        } catch (e) {
          add("warn", "Could not fetch metadata", { error: e.message });
        }

        // Resolve patient context
        let patientId = client.patient && client.patient.id ? client.patient.id : null;
        if (!patientId) {
          // Fallback: grab any patient (for standalone tests)
          try {
            const bundle = await client.request("Patient?_count=1");
            patientId = bundle.entry?.[0]?.resource?.id || null;
            add("warn", "No launch patient context; using first available patient", { patientId });
          } catch (e) {
            add("err", "Failed to resolve a patient", { error: e.message });
          }
        }

        // Patient details
        if (patientId) {
          try {
            const p = await client.request(`Patient/${patientId}`);
            add("ok", "Patient", {
              id: p.id,
              name: (p.name?.[0]?.given?.join(" ") || "") + " " + (p.name?.[0]?.family || ""),
              birthDate: p.birthDate,
              gender: p.gender
            });
          } catch (e) {
            add("warn", "Patient read failed", { error: e.message, patientId });
          }
        }

        // Get last encounter details
        let lastEncounter = null;
        if (patientId) {
          try {
            const encounters = await client.request(`Encounter?patient=${patientId}&_sort=-date&_count=1`);
            if (encounters.entry && encounters.entry.length > 0) {
              lastEncounter = encounters.entry[0].resource;
              add("highlight", "Last Encounter Details", {
                id: lastEncounter.id,
                status: lastEncounter.status,
                class: lastEncounter.class?.display || lastEncounter.class?.code,
                type: lastEncounter.type?.map(t => t.coding?.[0]?.display || t.text).join(", "),
                period: {
                  start: lastEncounter.period?.start,
                  end: lastEncounter.period?.end
                },
                location: lastEncounter.location?.map(loc => ({
                  display: loc.location?.display,
                  status: loc.status
                })) || [],
                reasonCode: lastEncounter.reasonCode?.map(r => 
                  r.coding?.[0]?.display || r.text
                ) || [],
                serviceProvider: lastEncounter.serviceProvider?.display
              });
            } else {
              add("warn", "No encounters found for patient", { patientId });
            }
          } catch (e) {
            add("warn", "Encounters fetch failed", { error: e.message });
          }
        }

        // ========= BILLING: ChargeItems for the CURRENT patient =========
        if (patientId) {
          try {
            const bundle = await client.request(
              `ChargeItem?patient=${patientId}&_elements=id,code,subject,effectiveTime&_count=50`
            );
            const items = (bundle.entry || []).map(e => e.resource);

            if (!items.length) {
              add("warn", "Billing (ChargeItem)", { message: "No ChargeItems found for this patient." });
            } else {
              const rows = items.map(ci => {
                const codings = (ci.code?.coding || []).map(c => ({
                  system: c.system,
                  code: c.code,
                  display: c.display
                }));
                return {
                  id: ci.id,
                  when: ci.effectiveTime || ci.occurrenceDateTime || undefined,
                  codes: codings.map(c =>
                    `${c.display || c.code || "(code)"}${c.code ? " ["+c.code+"]" : ""}`
                  )
                };
              });
              add("ok", "Billing (ChargeItem) for this patient", rows);
            }
          } catch (e) {
            add("warn", "ChargeItem fetch failed", { error: e.message });
          }
        }

        // ========= OPTIONAL: Tenant-wide scan (who has ChargeItems) =========
        // Requires server support for _include and typically user/* read scopes.
        try {
          const entries = await fetchAll(
            client,
            "ChargeItem?_include=ChargeItem:patient&_elements=id,subject,code&_count=50",
            6 // up to 6 pages
          );

          const patientsById = new Map();
          const byPatient = new Map();

          for (const e of entries) {
            const r = e.resource;
            if (!r) continue;
            if (r.resourceType === "Patient") {
              patientsById.set(r.id, r);
            } else if (r.resourceType === "ChargeItem") {
              const pid = r.subject?.reference?.split("/")[1];
              if (!pid) continue;
              const codes = (r.code?.coding || []).map(cd =>
                `${cd.display || cd.code || "(code)"}${cd.code ? " ["+cd.code+"]" : ""}`
              );
              if (!byPatient.has(pid)) byPatient.set(pid, new Set());
              codes.forEach(c => byPatient.get(pid).add(c));
            }
          }

          const result = [...byPatient.entries()].map(([pid, set]) => {
            const p = patientsById.get(pid);
            const name = ((p?.name?.[0]?.given || []).join(" ") + " " + (p?.name?.[0]?.family || "")).trim();
            return { patient: `${name || "(Unnamed)"} (Patient/${pid})`, codes: [...set] };
          }).sort((a,b) => a.patient.localeCompare(b.patient));

          if (result.length) {
            add("ok", "Patients in tenant with ChargeItems", result);
          } else {
            add("warn", "Patients in tenant with ChargeItems", { message: "None found or _include not supported." });
          }
        } catch (e) {
          add("warn", "Tenant-wide ChargeItem scan failed", { error: e.message });
        }

        // ========= Radiology orders (ServiceRequest) =========
        if (patientId) {
          try {
            const radiologyOrders = await client.request(`ServiceRequest?patient=${patientId}&category=108252007&_count=20`);
            add("radiology", "Radiology Orders (ServiceRequest)", radiologyOrders.entry?.map(e => {
              const sr = e.resource;
              return {
                id: sr.id,
                status: sr.status,
                intent: sr.intent,
                priority: sr.priority,
                code: sr.code?.coding?.[0]?.display || sr.code?.text,
                subject: sr.subject?.reference,
                encounter: sr.encounter?.reference,
                authoredOn: sr.authoredOn,
                requester: sr.requester?.display,
                reasonCode: sr.reasonCode?.map(r => r.coding?.[0]?.display || r.text) || [],
                bodySite: sr.bodySite?.map(bs => bs.coding?.[0]?.display || bs.text) || [],
                note: sr.note?.map(n => n.text) || []
              };
            }) || []);
          } catch (e) {
            add("warn", "Radiology orders fetch failed", { error: e.message });
          }

          // Also try without category filter in case the specific SNOMED code isn't used
          try {
            const allServiceRequests = await client.request(`ServiceRequest?patient=${patientId}&_count=20`);
            const radiologyLikeOrders = allServiceRequests.entry?.filter(e => {
              const code = e.resource.code?.coding?.[0]?.display || e.resource.code?.text || "";
              return code.toLowerCase().includes("radiology") || 
                     code.toLowerCase().includes("imaging") || 
                     code.toLowerCase().includes("x-ray") ||
                     code.toLowerCase().includes("ct") ||
                     code.toLowerCase().includes("mri") ||
                     code.toLowerCase().includes("ultrasound");
            }).map(e => {
              const sr = e.resource;
              return {
                id: sr.id,
                status: sr.status,
                intent: sr.intent,
                priority: sr.priority,
                code: sr.code?.coding?.[0]?.display || sr.code?.text,
                subject: sr.subject?.reference,
                encounter: sr.encounter?.reference,
                authoredOn: sr.authoredOn,
                requester: sr.requester?.display,
                reasonCode: sr.reasonCode?.map(r => r.coding?.[0]?.display || r.text) || [],
                bodySite: sr.bodySite?.map(bs => bs.coding?.[0]?.display || bs.text) || [],
                note: sr.note?.map(n => n.text) || []
              };
            }) || [];
            
            if (radiologyLikeOrders.length > 0) {
              add("radiology", "All Service Requests (Imaging-related filtered)", radiologyLikeOrders);
            }
          } catch (e) {
            add("warn", "All service requests fetch failed", { error: e.message });
          }
        }

        // ========= Radiology reports (DiagnosticReport) =========
        if (patientId) {
          try {
            const radiologyReports = await client.request(`DiagnosticReport?patient=${patientId}&category=394914008&_count=20`);
            add("radiology", "Radiology Reports (DiagnosticReport)", radiologyReports.entry?.map(e => {
              const dr = e.resource;
              return {
                id: dr.id,
                status: dr.status,
                category: dr.category?.map(cat => cat.coding?.[0]?.display || cat.text) || [],
                code: dr.code?.coding?.[0]?.display || dr.code?.text,
                subject: dr.subject?.reference,
                encounter: dr.encounter?.reference,
                effectiveDateTime: dr.effectiveDateTime,
                issued: dr.issued,
                performer: dr.performer?.map(p => p.display) || [],
                resultsInterpreter: dr.resultsInterpreter?.map(ri => ri.display) || [],
                imagingStudy: dr.imagingStudy?.map(is => is.reference) || [],
                conclusion: dr.conclusion,
                conclusionCode: dr.conclusionCode?.map(cc => cc.coding?.[0]?.display || cc.text) || [],
                presentedForm: dr.presentedForm?.map(pf => ({
                  contentType: pf.contentType,
                  title: pf.title,
                  creation: pf.creation
                })) || []
              };
            }) || []);
          } catch (e) {
            add("warn", "Radiology reports fetch failed", { error: e.message });
          }

          // Also try without category filter
          try {
            const allDiagnosticReports = await client.request(`DiagnosticReport?patient=${patientId}&_count=20`);
            const radiologyLikeReports = allDiagnosticReports.entry?.filter(e => {
              const category = e.resource.category?.map(cat => cat.coding?.[0]?.display || cat.text).join(" ").toLowerCase() || "";
              const code = e.resource.code?.coding?.[0]?.display || e.resource.code?.text || "";
              return category.includes("radiology") || category.includes("imaging") ||
                     code.toLowerCase().includes("radiology") || 
                     code.toLowerCase().includes("imaging") || 
                     code.toLowerCase().includes("x-ray") ||
                     code.toLowerCase().includes("ct") ||
                     code.toLowerCase().includes("mri") ||
                     code.toLowerCase().includes("ultrasound");
            }).map(e => {
              const dr = e.resource;
              return {
                id: dr.id,
                status: dr.status,
                category: dr.category?.map(cat => cat.coding?.[0]?.display || cat.text) || [],
                code: dr.code?.coding?.[0]?.display || dr.code?.text,
                subject: dr.subject?.reference,
                encounter: dr.encounter?.reference,
                effectiveDateTime: dr.effectiveDateTime,
                issued: dr.issued,
                performer: dr.performer?.map(p => p.display) || [],
                resultsInterpreter: dr.resultsInterpreter?.map(ri => ri.display) || [],
                imagingStudy: dr.imagingStudy?.map(is => is.reference) || [],
                conclusion: dr.conclusion,
                conclusionCode: dr.conclusionCode?.map(cc => cc.coding?.[0]?.display || cc.text) || [],
                presentedForm: dr.presentedForm?.map(pf => ({
                  contentType: pf.contentType,
                  title: pf.title,
                  creation: pf.creation
                })) || []
              };
            }) || [];
            
            if (radiologyLikeReports.length > 0) {
              add("radiology", "All Diagnostic Reports (Imaging-related filtered)", radiologyLikeReports);
            }
          } catch (e) {
            add("warn", "All diagnostic reports fetch failed", { error: e.message });
          }
        }

        // ========= Observations from the last encounter =========
        if (lastEncounter) {
          try {
            const encounterObs = await client.request(`Observation?patient=${patientId}&encounter=${lastEncounter.id}&_count=50`);
            add("highlight", `Observations from Last Encounter (${lastEncounter.id})`, encounterObs.entry?.map(e => {
              const o = e.resource;
              const value =
                (o.valueQuantity ? `${o.valueQuantity.value} ${o.valueQuantity.unit}` : null) ||
                o.valueString ||
                (o.component?.length ? o.component.map(c =>
                  `${c.code?.coding?.[0]?.display || c.code?.text}: ${c.valueQuantity?.value} ${c.valueQuantity?.unit}`
                ).join(", ") : "No value recorded");
              return {
                id: o.id,
                code: o.code?.coding?.[0]?.code,
                display: o.code?.coding?.[0]?.display || o.code?.text,
                value,
                effectiveDateTime: o.effectiveDateTime,
                status: o.status,
                encounter: o.encounter?.reference
              };
            }) || []);
          } catch (e) {
            add("warn", "Encounter observations fetch failed", { error: e.message });
          }
        }

        // ========= Clinical context (Conditions & recent Observations) =========
        if (patientId) {
          try {
            const cond = await client.request(`Condition?patient=${patientId}&_count=20`);
            add("", "Conditions (up to 20)", cond.entry?.map(e => ({
              id: e.resource.id,
              code: e.resource.code?.coding?.[0]?.code,
              display: e.resource.code?.coding?.[0]?.display || e.resource.code?.text,
              clinicalStatus: e.resource.clinicalStatus?.coding?.[0]?.display
            })) || []);
          } catch (e) {
            add("warn", "Conditions fetch failed", { error: e.message });
          }

          try {
            const obs = await client.request(`Observation?patient=${patientId}&_count=20`);
            add("", "All Recent Observations (up to 20)", obs.entry?.map(e => {
              const o = e.resource;
              const value =
                (o.valueQuantity ? `${o.valueQuantity.value} ${o.valueQuantity.unit}` : null) ||
                o.valueString ||
                (o.component?.length ? o.component.map(c =>
                  `${c.code?.coding?.[0]?.display || c.code?.text}: ${c.valueQuantity?.value} ${c.valueQuantity?.unit}`
                ).join(", ") : "No value recorded");
              return {
                id: o.id,
                code: o.code?.coding?.[0]?.code,
                display: o.code?.coding?.[0]?.display || o.code?.text,
                value,
                effectiveDateTime: o.effectiveDateTime,
                status: o.status
              };
            }) || []);
          } catch (e) {
            add("warn", "Observations fetch failed", { error: e.message });
          }
        }

        // ========= Claims/Billing context endpoints (may be empty in sandbox) =========
        if (patientId) {
          const claimsEndpoints = [
            `Coverage?patient=${patientId}&_count=5`,
            `ExplanationOfBenefit?patient=${patientId}&_count=5`,
            `Claim?patient=${patientId}&_count=5`
          ];
          for (const path of claimsEndpoints) {
            try {
              const r = await client.request(path);
              const items = (r.entry || []).map(e => e.resource);
              add("", `Claims endpoint: ${path}`, items.slice(0, 5));
            } catch (e) {
              add("warn", `Claims endpoint failed: ${path}`, { error: e.message });
            }
          }
        }

      } catch (e) {
        add("err", "SMART connection failed", { error: e.message });
      }
    })();
  </script>
</body>
</html>
